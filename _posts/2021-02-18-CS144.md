---
title: 斯坦福计网实验 / CS144 Lab Assignments
categories: [CS]
comment: false
---

> CS 144: Introduction to Computer Networking, Fall 2020
>
> https://cs144.github.io/
>
> My Repo
>
> https://github.com/wine99/cs144-20fa
>

*LAB0 在 master 分支，LAB1 - 7 在对应名字的分支（完成到了 Lab4）。*

# Lab 0

## webget

### What is webget?

参照 lab0.pdf 2.1 Fetch a Web page, 如下所示。

[![sbYMvD.png](https://s3.ax1x.com/2021/01/24/sbYMvD.png)](https://imgchr.com/i/sbYMvD)

其效果等同于

[![sbTh4A.png](https://s3.ax1x.com/2021/01/24/sbTh4A.png)](https://imgchr.com/i/sbTh4A)

### Write Webget

参考 API 文档 https://cs144.github.io/doc/lab0/class_t_c_p_socket.html。

注意 lab0.pdf 中的几点提示：

+ Please note that in HTTP, each line must be ended with “\r\n” (it’s not sufficient to use just “\n” or endl).
+ Don’t forget to include the “Connection: close” line in your client’s request. This tells the server that it shouldn’t wait around for your client to send any more requests after this one. Instead, the server will send one reply and then will immediately end its outgoing bytestream (the one from the server’s socket to your socket). You’ll discover that your incoming byte stream has ended because your socket will reach “EOF” (end of file) when you have read the entire byte stream coming from the server. That’s how your client will know that the server has finished its reply.
+ Make sure to read and print all the output from the server until the socket reaches “EOF” (end of file) — a single call to read is not enough.

在 GET 请求中写明 `Connection: close` 可以让服务器马上进入连接释放的过程（发一个 FIN 过来），我们在发送完 GET 同样需要 `shutdown(SHUT_WR)`，进入连接释放过程（发一个 FIN 过去）。（不太理解的话，写完 Lab4，就能理解了。）

```cpp
void get_URL(const string &host, const string &path) {
    // Your code here.

    // You will need to connect to the "http" service on
    // the computer whose name is in the "host" string,
    // then request the URL path given in the "path" string.

    // Then you'll need to print out everything the server sends back,
    // (not just one call to read() -- everything) until you reach
    // the "eof" (end of file).

    // cerr << "Function called: get_URL(" << host << ", " << path << ").\n";
    // cerr << "Warning: get_URL() has not been implemented yet.\n";

    TCPSocket sock1;
    sock1.connect(Address(host, "http"));
    sock1.write("GET " + path + " HTTP/1.1\r\n" + "Host: " + host + "\r\n" + "Connection: close\r\n\r\n");
    while (!sock1.eof()) {
        cout << sock1.read();
    }
    sock1.shutdown(SHUT_WR);
}
```

## An in-memory reliable byte stream

注意下面代码中的 `buffer_size` 为缓冲的内容大小（等于 `_stream.size()`），`capacity` 才是缓冲的大小。只有当 `input_ended` 为真并且 `buffer_size` 为 0 时，才是 EOF。

`byte_stream.hh`:

```cpp
class ByteStream {
  private:
    // Your code here -- add private members as necessary.

    // Hint: This doesn't need to be a sophisticated data structure at
    // all, but if any of your tests are taking longer than a second,
    // that's a sign that you probably want to keep exploring
    // different approaches.

    bool _error = false;  //!< Flag indicating that the stream suffered an error.
    bool _input_ended = false;
    size_t _capacity;
    size_t _buffer_size = 0;
    size_t _bytes_written = 0;
    size_t _bytes_read = 0;
    std::list<char> _stream{};

  public:
```

`byte_stream.cc`:

```cpp
#include "byte_stream.hh"

#include <string>

// Dummy implementation of a flow-controlled in-memory byte stream.

// For Lab 0, please replace with a real implementation that passes the
// automated checks run by `make check_lab0`.

// You will need to add private members to the class declaration in `byte_stream.hh`

template <typename... Targs>
void DUMMY_CODE(Targs &&... /* unused */) {}

using namespace std;

ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {}

size_t ByteStream::write(const string &data) {
    size_t write_count = 0;
    for (const char c : data) {
        // not very efficient to do conditional in loop
        if (_capacity - _buffer_size <= 0)
            break;
        else {
            _stream.push_back(c);
            ++_buffer_size;
            ++_bytes_written;
            ++write_count;
        }
    }

    return write_count;
}

//! \param[in] len bytes will be copied from the output side of the buffer
string ByteStream::peek_output(const size_t len) const {
    const size_t peek_length = len > _buffer_size ? _buffer_size : len;
    list<char>::const_iterator it = _stream.begin();
    advance(it, peek_length);
    return string(_stream.begin(), it);
}

//! \param[in] len bytes will be removed from the output side of the buffer
void ByteStream::pop_output(const size_t len) {
    size_t pop_length = len > _buffer_size ? _buffer_size : len;
    _bytes_read += pop_length;
    _buffer_size -= pop_length;
    while (pop_length--)
        _stream.pop_front();
}

//! Read (i.e., copy and then pop) the next "len" bytes of the stream
//! \param[in] len bytes will be popped and returned
//! \returns a string
std::string ByteStream::read(const size_t len) {
    const string result = peek_output(len);
    pop_output(len);
    return result;
}

void ByteStream::end_input() { _input_ended = true; }

bool ByteStream::input_ended() const { return _input_ended; }

size_t ByteStream::buffer_size() const { return _buffer_size; }

bool ByteStream::buffer_empty() const { return _stream.size() == 0; }

bool ByteStream::eof() const { return _input_ended && buffer_empty(); }

size_t ByteStream::bytes_written() const { return _bytes_written; }

size_t ByteStream::bytes_read() const { return _bytes_read; }

size_t ByteStream::remaining_capacity() const { return _capacity - _buffer_size; }
```

# Lab 1

## 任务

[![sLrj9e.png](https://s3.ax1x.com/2021/01/25/sLrj9e.png)](https://imgchr.com/i/sLrj9e)

TCP 接受方接收到乱序且可能重叠的报文段，StreamReassembler 需要将收到的报文段按情况送入 ByteStream (lab0 实现的），或丢弃，或暂存（在合适的时候重组送入 ByteStream）。

注意点：
+ 报文段包含索引、长度、内容，lab1 的索引从 0 开始增长，不会溢出绕回。
+ 任何报文段，包括新收到的和暂存的，只要可以，就应该立刻送入 ByteStream（可能需要手动重组和去重叠）。
+ 容量的限制如下图所示。

[![sLc0U0.png](https://s3.ax1x.com/2021/01/25/sLc0U0.png)](https://imgchr.com/i/sLc0U0)

## 思路

+ 用 set 来暂存报文段，按照报文段的 index 大小对比重载 < 运算符。
+ 用 _eof 来保存是否已经收到过有 EOF 标识的段。
+ 收到新段时，通过对比新段的 index、length 和 _first_unacceptable，_first_unassembled 对新段进行必要的剪切，然后处理重叠（调用 _handle_overlap）。
+ 处理重叠的逻辑：遍历每个暂存段，如果与新段产生重叠，合并暂存段与新段（调用 _merge_seg，总是往新段上合并，合并后删除重叠的暂存段）。
+ 合并段的方法：分类讨论，两个段总共会有四种不同的重叠情况，分别处理。
+ 处理完重叠后，调用 _stitch_output：遍历所有暂存段，将可合并的暂存段接入 ByteStream 中。
+ 最后，当 _eof 为真且 unassembled_bytes 为 0 时，调用 ByteSteram 的 end_input。

## 代码

stream_reassembler.hh：

```cpp
class StreamReassembler {
  private:
    // Your code here -- add private members as necessary.

    ByteStream _output;  //!< The reassembled in-order byte stream
    size_t _capacity;    //!< The maximum number of bytes
    size_t _first_unread = 0;
    size_t _first_unassembled = 0;
    size_t _first_unacceptable;
    bool _eof = false;
    struct seg {
        size_t index;
        size_t length;
        std::string data;
        bool operator<(const seg t) const { return index < t.index; }
    };
    std::set<seg> _stored_segs = {};

    void _add_new_seg(seg &new_seg, const bool eof);
    void _handle_overlap(seg &new_seg);
    void _stitch_output();
    void _stitch_one_seg(const seg &new_seg);
    void _merge_seg(seg &new_seg, const seg &other);

  public:
```

stream_reassembler.cc：

注意 _add_new_seg 中关于 EOF 的处理细节。

```cpp
#include "stream_reassembler.hh"

// Dummy implementation of a stream reassembler.

// For Lab 1, please replace with a real implementation that passes the
// automated checks run by `make check_lab1`.

// You will need to add private members to the class declaration in `stream_reassembler.hh`

template <typename... Targs>
void DUMMY_CODE(Targs &&... /* unused */) {}

using namespace std;

StreamReassembler::StreamReassembler(const size_t capacity)
    : _output(capacity), _capacity(capacity), _first_unacceptable(capacity) {}

//! \details This function accepts a substring (aka a segment) of bytes,
//! possibly out-of-order, from the logical stream, and assembles any newly
//! contiguous substrings and writes them into the output stream in order.
void StreamReassembler::push_substring(const string &data, const size_t index, const bool eof) {
    _first_unread = _output.bytes_read();
    _first_unacceptable = _first_unread + _capacity;
    seg new_seg = {index, data.length(), data};
    _add_new_seg(new_seg, eof);
    _stitch_output();
    if (empty() && _eof)
        _output.end_input();
}

void StreamReassembler::_add_new_seg(seg &new_seg, const bool eof) {
    // check capacity limit, if unmeet limit, return
    // cut the bytes in NEW_SEG that will overflow the _CAPACITY
    // note that the EOF should also be cut
    // cut the bytes in NEW_SEG that are already in _OUTPUT
    // _HANDLE_OVERLAP()
    // update _EOF
    if (new_seg.index >= _first_unacceptable)
        return;
    bool eof_of_this_seg = eof;
    if (int overflow_bytes = new_seg.index + new_seg.length - _first_unacceptable; overflow_bytes > 0) {
        int new_length = new_seg.length - overflow_bytes;
        if (new_length <= 0)
            return;
        eof_of_this_seg = false;
        new_seg.length = new_length;
        new_seg.data = new_seg.data.substr(0, new_seg.length);
    }
    if (new_seg.index < _first_unassembled) {
        int new_length = new_seg.length - (_first_unassembled - new_seg.index);
        if (new_length <= 0)
            return;
        new_seg.length = new_length;
        new_seg.data = new_seg.data.substr(_first_unassembled - new_seg.index, new_seg.length);
        new_seg.index = _first_unassembled;
    }
    _handle_overlap(new_seg);
    // if EOF was received before, it should remain valid
    _eof = _eof || eof_of_this_seg;
}

void StreamReassembler::_handle_overlap(seg &new_seg) {
    for (auto it = _stored_segs.begin(); it != _stored_segs.end();) {
        auto next_it = ++it;
        --it;
        if ((new_seg.index >= it->index && new_seg.index < it->index + it->length) ||
            (it->index >= new_seg.index && it->index < new_seg.index + new_seg.length)) {
            _merge_seg(new_seg, *it);
            _stored_segs.erase(it);
        }
        it = next_it;
    }
    _stored_segs.insert(new_seg);
}

void StreamReassembler::_stitch_output() {
    // _FIRST_UNASSEMBLED is the expected next index_FIRST_UNASSEMBLED
    // compare _STORED_SEGS.begin()->index with
    // if equals, then _STITCH_ONE_SEG() and erase this seg from set
    // continue compare until not equal or empty
    while (!_stored_segs.empty() && _stored_segs.begin()->index == _first_unassembled) {
        _stitch_one_seg(*_stored_segs.begin());
        _stored_segs.erase(_stored_segs.begin());
    }
}

void StreamReassembler::_stitch_one_seg(const seg &new_seg) {
    // write string of NEW_SEG into _OUTPUT
    // update _FIRST_UNASSEMBLED
    _output.write(new_seg.data);
    _first_unassembled += new_seg.length;
    // both way of updating _FIRST_UNASSEMBLED is ok
    // _first_unassembled = _output.bytes_written();
}

void StreamReassembler::_merge_seg(seg &new_seg, const seg &other) {
    size_t n_index = new_seg.index;
    size_t n_end = new_seg.index + new_seg.length;
    size_t o_index = other.index;
    size_t o_end = other.index + other.length;
    string new_data;
    if (n_index <= o_index && n_end <= o_end) {
        new_data = new_seg.data + other.data.substr(n_end - o_index, n_end - o_end);
    } else if (n_index <= o_index && n_end >= o_end) {
        new_data = new_seg.data;
    } else if (n_index >= o_index && n_end <= o_end) {
        new_data =
            other.data.substr(0, n_index - o_index) + new_seg.data + other.data.substr(n_end - o_index, n_end - o_end);
    } else /* if (n_index >= o_index && n_end <= o_end) */ {
        new_data = other.data.substr(0, n_index - o_index) + new_seg.data;
    }
    new_seg.index = n_index < o_index ? n_index : o_index;
    new_seg.length = (n_end > o_end ? n_end : o_end) - new_seg.index;
    new_seg.data = new_data;
}

size_t StreamReassembler::unassembled_bytes() const {
    size_t unassembled_bytes = 0;
    for (auto it = _stored_segs.begin(); it != _stored_segs.end(); ++it)
        unassembled_bytes += it->length;
    return unassembled_bytes;
}

bool StreamReassembler::empty() const { return unassembled_bytes() == 0; }
```

## VS Code 调试方法

测试样例对应的源文件在 ./tests 文件夹中，如下图所示。

[![sO3UZd.png](https://s3.ax1x.com/2021/01/25/sO3UZd.png)](https://imgchr.com/i/sO3UZd)

对应的可执行文件在 ./build/tests 中。

通常 VSC 的 launch.json 中自动生成了一个名为 debug current file 的 launch targe，它有一个前置任务 C/C++: g++ build active file。仿照该 lanuch targe，可以写一个名为 debug lab test 的 launch targe。如下所示。

launch.json:

```json
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "debug lab test",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/tests/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "debug webget",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/apps/webget",
            "args": ["cs144.keithw.org", "/hello"],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            // "preLaunchTask": "C/C++: g++ build active file",
            "preLaunchTask": "build project",
            "miDebuggerPath": "/usr/bin/gdb"
        },
        {
            "name": "debug current file",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "C/C++: g++ build active file",
            "miDebuggerPath": "/usr/bin/gdb"
        }
    ]
}
```

tasks.json:

```json
{
    "tasks": [
        {
            "type": "shell",
            "label": "C/C++: g++ build active file",
            "command": "/usr/bin/g++",
            "args": [
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${workspaceFolder}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "type": "shell",
            "label": "build project",
            "command": "cd build && make -j8",
            "args": [],
        },
    ],
    "version": "2.0.0"
}
```

然后就可以在测试源代码中打断点调试。

[![sOGQgK.png](https://s3.ax1x.com/2021/01/25/sOGQgK.png)](https://imgchr.com/i/sOGQgK)

# Lab 2


## Translating between 64-bit indexes and 32-bit seqnos

[![ydf2M4.png](https://s3.ax1x.com/2021/02/09/ydf2M4.png)](https://imgchr.com/i/ydf2M4)

注意 wrapping_integers.hh 中的这三个方法：

```cpp
inline int32_t operator-(WrappingInt32 a, WrappingInt32 b) { return a.raw_value() - b.raw_value(); }

//! \brief The point `b` steps past `a`.
inline WrappingInt32 operator+(WrappingInt32 a, uint32_t b) { return WrappingInt32{a.raw_value() + b}; }

//! \brief The point `b` steps before `a`.
inline WrappingInt32 operator-(WrappingInt32 a, uint32_t b) { return a + -b; }
```

下面的两个加减，分别是在 WrappingInt32 上加上或减去一个 uint32_t，得到的结果仍然是一个 WrappingInt32，其意义是分别为把 a 这个 WrappingInt32 向前或向后移动 |b| 个单位距离。

而第一个减法重载，是两个 WrappingInt32 相减，得到的是一个 int32_t，要想理解其意义，首先要弄懂下面的代码：

```cpp
// 2 ^ 32 = 4294967296

uint32_t a = 1;
uint32_t b = 0;
uint32_t x = a - b;
int32_t  y = a - b;
// x=1 y=1
uint32_t x = b - a;
int32_t  y = b - a;
// x=4294967295 y=-1

uint32_t a = 1;
uint32_t b = static_cast<uint32_t>((1UL << 32) - 1UL);
uint32_t x = a - b;
int32_t  y = a - b;
// x=2 y=2
uint32_t x = b - a;
int32_t  y = b - a;
// x=4294967294 y=-2
```

上面的运算说明：`c(int32_t) = a(uint32_t) - b(uint32_t)` 的 c 的绝对值的意义是从 b 走到 a 需要花费的最少步数，如果 c 是正数，则向数轴的正方向走，否则向反方向走。之所以存在最小步数一说，是因为往反方向走穿越 0 会到 2^32 - 1，往正方向走穿越 2^32 - 1 会回到 0。这个步数也一定不会超过 2^31 步。第一个减法也是这样的意义，代表了从 WrappingInt32 b 走到 WrappingInt32 a 最少需要的步数。

理解了这三个运算符重载后，就可以编写 Wrapping_integers.cc 了：

```cpp
WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) { return isn + static_cast<uint32_t>(n); }

uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) {
    // STEP ranges from -UINT32_MAX/2 to UINT32_MAX/2
    // in most cases, just adding STEP to CHECKPOINT will get the absolute seq
    // but if after adding, the absolute seq is negative, it should add another (1UL << 32)
    // (this means the checkpoint is near 0 so the new seq should always go bigger
    // eg. test/unwrap.cc line 25)
    int32_t steps = n - wrap(checkpoint, isn);
    int64_t res = checkpoint + steps;
    return res >= 0 ? checkpoint + steps : res + (1UL << 32);
}
```

首先看把 64 位的 index 转换为 WrappingInt32 的 wrap 函数。根据上面的表格，显然，只需要利用加法重载，把 ISN 往前走 n(=index) 步就可以了。

然后看 unwrap 函数，起作用是把新接收到的报文段的 seqno（WrappingInt32）转换为 64 位的 index。seqno 转 index 的结果显然不唯一，我们想要的是与上一次收到的报文段的 index（checkpoint）最接近的那个转换结果。于是，可以先用刚写好的 wrap 函数把 checkpoint 变为 WrappingInt32，然后利用第一个减法重载，找出这个转换后的 seqno 最少需要走几步可以到新报文的 seqno，然后把这个步数加到 checkpoint 上。注意这里有一个特殊情况（见代码注释），因为我们有可能是往数轴的反方向走的，可能走完之后 res 的值是个负数，这时候需要在加上一个 2^32。

## Implementing the TCP receiver

注意测试里面的特殊情况，例如

- SYN with DATA
- SYN with DATA with FIN
- SYN + FIN
- SYN + DATA with FIN + DATA
- ...

然后根据未通过的测试，一步步完善逻辑，测试全部通过后再重新简化代码，最终得到解法如下（部分思路见注释）：

```cpp
void TCPReceiver::segment_received(const TCPSegment &seg) {
    TCPHeader header = seg.header();
    if (header.syn && _syn)
        return;
    if (header.syn) {
        _syn = true;
        _isn = header.seqno.raw_value();
    }
    // note that fin flag seg can carry payload
    if (_syn && header.fin)
        _fin = true;
    size_t absolute_seqno = unwrap(header.seqno, WrappingInt32(_isn), _checkpoint);
    _reassembler.push_substring(seg.payload().copy(), header.syn ? 0 : absolute_seqno - 1, header.fin);
    _checkpoint = absolute_seqno;
}

optional<WrappingInt32> TCPReceiver::ackno() const {
    // Return the corresponding 32bit seqno of _reassembler.first_unassembled().
    // Translate from Stream Index to Absolute Sequence Number is simple, just add 1.
    // If outgoing ack is corresponding to FIN
    // (meaning FIN is received and all segs are assembled),
    // add another 1.
    size_t shift = 1;
    if (_fin && _reassembler.unassembled_bytes() == 0)
        shift = 2;
    if (_syn)
        return wrap(_reassembler.first_unassembled() + shift, WrappingInt32(_isn));
    return {};
}

size_t TCPReceiver::window_size() const {
    // equal to first_unacceptable - first_unassembled
    return _capacity - stream_out().buffer_size();
}
```

# Lab 3

## 总体思路

tick 不需要我们来调用，参数的意义是距离上次 tick 被调用过去的时间，也不需要我们来设定。我们只需要在 tick 中实现，通过参数判断过去了多少时间，需要执行何种操作即可。

注意根据文档，我们要不需要实现选择重传，而是类似回退 N，需要存储已发送并且未被确认的段，进行累计确认，超时时只要重传这些段中最早的那一个即可。

TCPReceiver 调用 unwrap 时的 checkpoint 是上一个接收到的报文段的 absolute_seqno，TCPSender 调用 unwrap 时的 checkpoint 是 `_next_seqno`。

我的实现中计时器开关的处理：

- 发送新报文段时若计时器未打开，开启
- ack_received() 中，如果有报文段被正确地确认，重置计时器和 RTO，如果所有报文段均被确认（bytes in flight == 0），关闭计时器
- tick() 中，若计时器为关闭状态，直接返回，否则累加计时然后处理超时

## 添加的成员变量

```cpp
class TCPSender {
  private:
    bool _syn_sent = false;
    bool _fin_sent = false;
    uint64_t _bytes_in_flight = 0;
    uint16_t _receiver_window_size = 0;
    uint16_t _receiver_free_space = 0;
    uint16_t _consecutive_retransmissions = 0;
    unsigned int _rto = 0;
    unsigned int _time_elapsed = 0;
    bool _timer_running = false;
    std::queue<TCPSegment> _segments_outstanding{};

    bool _ack_valid(uint64_t abs_ackno);
    void _send_segment(TCPSegment &seg);
};
```

- `send_segment(TCPSegment &seg)` 只在 `fill_window()` 中被调用，重传只需要 `_segments_out.push(_segments_outstanding.front())`
- `_receiver_window_size` 保存收到有效（有效的含义见上面 `ack_valid()`）确认报文段时，报文段携带的接收方窗口大小
- `_receiver_free_space` 是在 `_receiver_window_size` 的基础上，再减去已发送的报文段可能占用的空间（`_bytes_in_flight`）

## `fill_window()` 实现

- 如果 SYN 未发送，发送然后返回
- 如果 SYN 未被应答，返回
- 如果 FIN 已经发送，返回
- 如果 _stream 暂时没有内容但并没有 EOF，返回
- 如果 `_receiver_window_size` 不为 0
  1. 当 `receiver_free_space` 不为 0，尽可能地填充 payload
  2. 如果 _stream 已经 EOF，且 `_receiver_free_space` 仍不为 0，填上 FIN（fin 也会占用 _receiver_free_space）
  3. 如果 `_receiver_free_space` 还不为 0，且 _stream 还有内容，回到步骤 1 继续填充
- 如果 `_receiver_window_size` 为 0，则需要发送零窗口探测报文
  - 如果 `_receiver_free_space` 为 0
    - 如果 _stream 已经 EOF，发送仅携带 FIN 的报文
    - 如果 _stream 还有内容，发送仅携带一位数据的报文
  - 之所以还需要判断 `_receiver_free_space` 为 0，是因为这些报文段在此处应该只发送一次，后续的重传由 tick() 函数控制，而当发送了零窗口报文段后 `_receiver_free_space` 的值就会从原来的与 `_receiver_window_size` 相等的 0 变成 -1

```cpp
void TCPSender::fill_window() {
    if (!_syn_sent) {
        _syn_sent = true;
        TCPSegment seg;
        seg.header().syn = true;
        send_segment(seg);
        return;
    }
    if (!_segments_outstanding.empty() && _segments_outstanding.front().header().syn)
        return;
    if (!_stream.buffer_size() && !_stream.eof())
        return;
    if (_fin_sent)
        return;

    if (_receiver_window_size) {
        while (_receiver_free_space) {
            TCPSegment seg;
            size_t payload_size = min({_stream.buffer_size(),
                                       static_cast<size_t>(_receiver_free_space),
                                       static_cast<size_t>(TCPConfig::MAX_PAYLOAD_SIZE)});
            seg.payload() = _stream.read(payload_size);
            if (_stream.eof() && static_cast<size_t>(_receiver_free_space) > payload_size) {
                seg.header().fin = true;
                _fin_sent = true;
            }
            send_segment(seg);
            if (_stream.buffer_empty())
                break;
        }
    } else if (_receiver_free_space == 0) {
        // The zero-window-detect-segment should only be sent once (retransmition excute by tick function).
        // Before it is sent, _receiver_free_space is zero. Then it will be -1.
        TCPSegment seg;
        if (_stream.eof()) {
            seg.header().fin = true;
            _fin_sent = true;
            send_segment(seg);
        } else if (!_stream.buffer_empty()) {
            seg.payload() = _stream.read(1);
            send_segment(seg);
        }
    }
}

void TCPSender::send_segment(TCPSegment &seg) {
    seg.header().seqno = wrap(_next_seqno, _isn);
    _next_seqno += seg.length_in_sequence_space();
    _bytes_in_flight += seg.length_in_sequence_space();
    if (_syn_sent)
        _receiver_free_space -= seg.length_in_sequence_space();
    _segments_out.push(seg);
    _segments_outstanding.push(seg);
    if (!_timer_running) {
        _timer_running = true;
        _time_elapsed = 0;
    }
}
```

## `ack_received()` 实现

代码比较直白，注意进行累计确认之后，如果还有未被确认的报文段，`_receiver_free_space` 的值应为：收到的确认号绝对值 + 窗口大小 - 首个未确认报文的序号绝对值 - 未确认报文段的长度总和。

```cpp
void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {
    uint64_t abs_ackno = unwrap(ackno, _isn, _next_seqno);
    if (!ack_valid(abs_ackno)) {
        // cout << "invalid ackno!\n";
        return;
    }
    _receiver_window_size = window_size;
    _receiver_free_space = window_size;
    while (!_segments_outstanding.empty()) {
        TCPSegment seg = _segments_outstanding.front();
        if (unwrap(seg.header().seqno, _isn, _next_seqno) + seg.length_in_sequence_space() <= abs_ackno) {
            _bytes_in_flight -= seg.length_in_sequence_space();
            _segments_outstanding.pop();
            // Do not do the following operations outside while loop.
            // Because if the ack is not corresponding to any segment in the segment_outstanding,
            // we should not restart the timer.
            _time_elapsed = 0;
            _rto = _initial_retransmission_timeout;
            _consecutive_retransmissions = 0;
        } else {
            break;
        }
    }
    if (!_segments_outstanding.empty()) {
        _receiver_free_space = static_cast<uint16_t>(
            abs_ackno + static_cast<uint64_t>(window_size) -
            unwrap(_segments_outstanding.front().header().seqno, _isn, _next_seqno) - _bytes_in_flight);
    }

    if (!_bytes_in_flight)
        _timer_running = false;
    // Note that test code will call it again.
    fill_window();
}

// See test code send_window.cc line 113 why the commented code is wrong.
bool TCPSender::_ack_valid(uint64_t abs_ackno) {
    return abs_ackno <= _next_seqno &&
           //  abs_ackno >= unwrap(_segments_outstanding.front().header().seqno, _isn, _next_seqno) +
           //          _segments_outstanding.front().length_in_sequence_space();
           abs_ackno >= unwrap(_segments_outstanding.front().header().seqno, _isn, _next_seqno);
}
```

## tick() 实现

注意，窗口大小为 0 时不需要增加 RTO。但是发送 SYN 时，窗口为初始值也为 0，而 SYN 超时是需要增加 RTO 的。

```cpp
void TCPSender::tick(const size_t ms_since_last_tick) {
    if (!_timer_running)
        return;
    _time_elapsed += ms_since_last_tick;
    if (_time_elapsed >= _rto) {
        _segments_out.push(_segments_outstanding.front());
        if (_receiver_window_size || _segments_outstanding.front().header().syn) {
            ++_consecutive_retransmissions;
            _rto <<= 1;
        }
        _time_elapsed = 0;
    }
}
```

## 其他代码

```cpp
#include <algorithm>

TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional<WrappingInt32> fixed_isn)
    : _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))
    , _initial_retransmission_timeout{retx_timeout}
    , _stream(capacity)
    , _rto{retx_timeout} {}

uint64_t TCPSender::bytes_in_flight() const { return _bytes_in_flight; }

unsigned int TCPSender::consecutive_retransmissions() const { return _consecutive_retransmissions; }

void TCPSender::send_empty_segment() {
    TCPSegment seg;
    seg.header().seqno = wrap(_next_seqno, _isn);
    _segments_out.push(seg);
}
```

# Lab 4

## 任务

本节实现 TCPConnection 类，实例化这个类将作为一个完整的 TCP 连接中的一个 peer（可以充当任意一方，Server 或 Client）。前面两个实验分别实现的 TCPSender 和 TCPReceiver 并不能作为一个独立的 Server 或 Client，这两个类的实例是用作 TCPConnection 实例的内部成员，即下图。

[![ygfFsI.png](https://s3.ax1x.com/2021/02/17/ygfFsI.png)](https://imgchr.com/i/ygfFsI)

## Sender 和 Receiver 的作用

- 收到报文段时
  - 通知 _receiver：根据报文段的 seqno、SYN、FIN 和 payload，以及当前状态，更新 ackno；收集数据
  - 通知 _sender：根据报文段的 ackno 以及当前状态，更新 next_seqno；更新 window_size
- 发送报文段时
  - sender 负责填充 payload、seqno、SYN、FIN，注意有可能既没有 payload 也没有 S、F 标识（empty segment），这和 Lab3 实现的 _sender 的 ack_received() 逻辑不同
  - _receiver 负责填充 ackno、window size

## FSM

结合 Lab2、Lab3 讲义中的 TCPSender 和 TCPReceiver 的状态转换图，tcp_state.cc 中 TCPConnection 的各状态与 sender、receiver 状态的对应关系，以及下面的 TCPConnection 的状态转换图，理解整个 TCP 连接。

[![yg5iQJ.jpg](https://s3.ax1x.com/2021/02/17/yg5iQJ.jpg)](https://imgchr.com/i/yg5iQJ)

## Edge case

在实现过程中，需要额外关注收到报文段时 TCPSender 和 TCPConnection 的逻辑的不同之处。这些细节来源于

1. Lab2 中的 receiver 只关心收到数据和数据有关的标识；Lab3 中 sender 只关心收到的 ackno 和 win，不处理也不知道收到的数据和其他信息，在 _stream_in() 没有数据时可能不会做任何动作（我的 Lab3 实现是这样的），而在 Lab4 中可能还需要发一个空的 ACK 报文段
2. 连接建立和释放过程中的各种特殊情况
   1. 发完 SYN 后马上收到 RST
   2. 发完 SYN 后马上收到 FIN
   3. Simultaneous open
   4. Simultaneous shutdown
   5. ...

实验给出的测试套非常完备，覆盖了各种特殊情况，Simultaneous open 和 Simultaneous shutdown 的情况见下图。按照讲义所说，如果你的 Lab2 和 Lab3 实现非常 robust，Lab4 的大部分工作是 wire up 前面两个类的接口，但也有可能你需要修改前两个实验的实现。

下图出处：[TCP State Transitions](http://ttcplinux.sourceforge.net/documents/one/tcpstate/tcpstate.html)

[![yg7ih6.jpg](https://s3.ax1x.com/2021/02/17/yg7ih6.jpg)](https://imgchr.com/i/yg7ih6)[![yg7A1O.jpg](https://s3.ax1x.com/2021/02/17/yg7A1O.jpg)](https://imgchr.com/i/yg7A1O)

## 实现

我的实验四的函数框架参考了 [这篇博客](https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html)，但实现不同。我在网上浏览过的几个实现，均改动了 Lab2、Lab3 的函数签名，让 Lab2、Lab3 的实现变得不太干净。我的最终实现没有入侵 Lab3 和 Lab2 的代码，细节逻辑全部在 TCPConnection 类中完成。

注意如果 tests 文件夹中的测试全部通过但是 txrx.sh 中的测试不通过，并且不通过的原因是结果的哈希值不同，去掉所有的自己添加的打印语句，再进行测试。

实验四刚开始时一度想要放弃，但最终花费的时间居然比实验三要少（实验三零零碎碎花了六天左右，实验四大概花费了集中的两天半时间）。通过全部测试的时候，还感觉有点懵逼，怎么就通过了，我真的把细节都处理完了？第一次意识到，复杂的项目中，完备的测试比“充满自信”的实现代码可靠多了，也不得不感慨课程质量之高以及讲师和助教付出的心血。

[![y2kzRO.png](https://s3.ax1x.com/2021/02/17/y2kzRO.png)](https://imgchr.com/i/y2kzRO)

## 代码

### 添加的成员变量

```cpp
class TCPConnection {
  private:
    size_t _time_since_last_segment_received{0};
    bool _active{true};

    void send_sender_segments();
    void clean_shutdown();
    void unclean_shutdown();
```

### 实现代码

```cpp
#include "tcp_connection.hh"

#include <iostream>

using namespace std;

size_t TCPConnection::remaining_outbound_capacity() const { return _sender.stream_in().remaining_capacity(); }

size_t TCPConnection::bytes_in_flight() const { return _sender.bytes_in_flight(); }

size_t TCPConnection::unassembled_bytes() const { return _receiver.unassembled_bytes(); }

size_t TCPConnection::time_since_last_segment_received() const { return _time_since_last_segment_received; }

bool TCPConnection::active() const { return _active; }

void TCPConnection::segment_received(const TCPSegment &seg) {
    if (!_active)
        return;
    _time_since_last_segment_received = 0;
    // State: closed
    if (!_receiver.ackno().has_value() && _sender.next_seqno_absolute() == 0) {
        if (!seg.header().syn)
            return;
        _receiver.segment_received(seg);
        connect();
        return;
    }
    // State: syn sent
    if (_sender.next_seqno_absolute() > 0 && _sender.bytes_in_flight() == _sender.next_seqno_absolute() &&
        !_receiver.ackno().has_value()) {
        if (seg.payload().size())
            return;
        if (!seg.header().ack) {
            if (seg.header().syn) {
                // simultaneous open
                _receiver.segment_received(seg);
                _sender.send_empty_segment();
            }
            return;
        }
        if (seg.header().rst) {
            _receiver.stream_out().set_error();
            _sender.stream_in().set_error();
            _active = false;
            return;
        }
    }
    _receiver.segment_received(seg);
    _sender.ack_received(seg.header().ackno, seg.header().win);
    // Lab3 behavior: fill_window() will directly return without sending any segment.
    // See tcp_sender.cc line 42
    if (_sender.stream_in().buffer_empty() && seg.length_in_sequence_space())
        _sender.send_empty_segment();
    if (seg.header().rst) {
        _sender.send_empty_segment();
        unclean_shutdown();
        return;
    }
    send_sender_segments();
}

size_t TCPConnection::write(const string &data) {
    if (!data.size())
        return 0;
    size_t write_size = _sender.stream_in().write(data);
    _sender.fill_window();
    send_sender_segments();
    return write_size;
}

//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method
void TCPConnection::tick(const size_t ms_since_last_tick) {
    if (!_active)
        return;
    _time_since_last_segment_received += ms_since_last_tick;
    _sender.tick(ms_since_last_tick);
    if (_sender.consecutive_retransmissions() > TCPConfig::MAX_RETX_ATTEMPTS)
        unclean_shutdown();
    send_sender_segments();
}

void TCPConnection::end_input_stream() {
    _sender.stream_in().end_input();
    _sender.fill_window();
    send_sender_segments();
}

void TCPConnection::connect() {
    _sender.fill_window();
    send_sender_segments();
}

TCPConnection::~TCPConnection() {
    try {
        if (active()) {
            cerr << "Warning: Unclean shutdown of TCPConnection\n";
            _sender.send_empty_segment();
            unclean_shutdown();
        }
    } catch (const exception &e) {
        std::cerr << "Exception destructing TCP FSM: " << e.what() << std::endl;
    }
}

void TCPConnection::send_sender_segments() {
    TCPSegment seg;
    while (!_sender.segments_out().empty()) {
        seg = _sender.segments_out().front();
        _sender.segments_out().pop();
        if (_receiver.ackno().has_value()) {
            seg.header().ack = true;
            seg.header().ackno = _receiver.ackno().value();
            seg.header().win = _receiver.window_size();
        }
        _segments_out.push(seg);
    }
    clean_shutdown();
}

void TCPConnection::unclean_shutdown() {
    // When this being called, _sender.stream_out() should not be empty.
    _receiver.stream_out().set_error();
    _sender.stream_in().set_error();
    _active = false;
    TCPSegment seg = _sender.segments_out().front();
    _sender.segments_out().pop();
    seg.header().ack = true;
    if (_receiver.ackno().has_value())
        seg.header().ackno = _receiver.ackno().value();
    seg.header().win = _receiver.window_size();
    seg.header().rst = true;
    _segments_out.push(seg);
}

void TCPConnection::clean_shutdown() {
    if (_receiver.stream_out().input_ended()) {
        if (!_sender.stream_in().eof())
            _linger_after_streams_finish = false;
        else if (_sender.bytes_in_flight() == 0) {
            if (!_linger_after_streams_finish || time_since_last_segment_received() >= 10 * _cfg.rt_timeout) {
                _active = false;
            }
        }
    }
}
```

## 性能优化

### 分析

由于没有做过 profiling，性能分析的工作抄了上面提到的博客的作业。

>  修改 `sponge/etc/cflags.cmake` 中的编译参数，将`-g`改为`-Og -pg`，使生成的程序具有分析程序可用的链接信息。
>
> ```bash
> make -j8
> ./apps/tcp_benchmark
> gprof ./apps/tcp_benchmark > prof.txt
> ```

[![y2nkwQ.png](https://s3.ax1x.com/2021/02/17/y2nkwQ.png)](https://imgchr.com/i/y2nkwQ)

如讲义中所说，很可能需要改动 ByteStream 或 StreamReassembler。调优方法是利用 buffer.h 中提供的 BufferList。实际上测试代码中就有用到 BufferList，简而言之它是一个 deque\<Buffer\>，而 Buffer 则在整个实现与测试代码中被大量使用，例如 payload() 就是一个 Buffer 实例。

### 改动

把 ByteStream 类中字节流的容器由 Lab0 最初的 `std::list<char> _stream{};` 改为 `BufferList _stream{};`。

byte_stream.cc 改动的函数：

```cpp
size_t ByteStream::write(const string &data) {
    size_t write_count = data.size();
    if (write_count > _capacity - _buffer_size)
        write_count = _capacity - _buffer_size;
    _stream.append(BufferList(move(string().assign(data.begin(), data.begin() + write_count))));
    _buffer_size += write_count;
    _bytes_written += write_count;
    return write_count;
}

//! \param[in] len bytes will be copied from the output side of the buffer
string ByteStream::peek_output(const size_t len) const {
    const size_t peek_length = len > _buffer_size ? _buffer_size : len;
    string str = _stream.concatenate();
    return string().assign(str.begin(), str.begin() + peek_length);
}

//! \param[in] len bytes will be removed from the output side of the buffer
void ByteStream::pop_output(const size_t len) {
    size_t pop_length = len > _buffer_size ? _buffer_size : len;
    _stream.remove_prefix(pop_length);
    _bytes_read += pop_length;
    _buffer_size -= pop_length;
}
```

### 改动后的 benchmark

[![y2KfoQ.png](https://s3.ax1x.com/2021/02/17/y2KfoQ.png)](https://imgchr.com/i/y2KfoQ)

## webget revisited

直接按照讲义中的步骤，把 Linux 自带的 TCPSocket，换成我们自己的实现。

```cpp
void get_URL(const string &host, const string &path) {
    CS144TCPSocket sock1{};
    sock1.connect(Address(host, "http"));
    sock1.write("GET " + path + " HTTP/1.1\r\n" + "Host: " + host + "\r\n" + "Connection: close\r\n\r\n");
    while (!sock1.eof()) {
        cout << sock1.read();
    }
    sock1.shutdown(SHUT_WR);
    sock1.wait_until_closed();
}
```

替换后 webget 依然 work（不知道为什么 WSL 替换后连接建立不起来，但在云主机上测试后没有问题），至此，手写 TCP 正式完成。
